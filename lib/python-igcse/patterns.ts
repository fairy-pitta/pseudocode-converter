export const PATTERNS = {
  COMMENT: /^#.*/,
  FUNCTION_DEF: /^def\s+(\w+)\(([^)]*)\)\s*:/,
  CLASS_DEF: /^class\s+(\w+)(?:\((\w+)\))?\s*:/,
  IF: /^if\s+(.+?)\s*:/,
  ELIF: /^elif\s+(.+?)\s*:/,
  ELSE: /^else\s*:/,
  FOR_RANGE: /^for\s+(\w+)\s+in\s+range\(([^)]*)\)\s*:/,
  FOR_COLLECTION: /^for\s+(\w+)\s+in\s+([^:]+?)\s*:/,
  WHILE: /^while\s+(.+?)\s*:/,
  RETURN: /^return(?:\s+(.*))?/,
  PRINT: /^print\((.*)\)$/,
  INPUT: /(\w+)\s*=\s*input\((?:["'].*?["'])?\)/,
  CONSTANT: /^([A-Z][A-Z_]*)\s*=\s*([^=].*)$/,
  ASSIGNMENT: /^([A-Za-z_]\w*)\s*=\s*([^=].*)$/,
  COMPOUND_ASSIGNMENT: /^([A-Za-z_]\w*)\s*(\+=|\-=|\*=|\/=|%=|\/\/=|\*\*=)\s*(.+)$/,
  VARIABLE_DECLARATION: /^[A-Za-z_]\w*\s*=\s*[^=]/,
  FOR_VARIABLE: /^for\s+(\w+)\s+in/,
  LIST_COMPREHENSION: /^([a-zA-Z_]\w*)\s*=\s*\[(.+?)\s+for\s+(\w+)\s+in\s+range\((\d+)\)\]$/,
  LAMBDA: /^([a-zA-Z_]\w*)\s*=\s*lambda\s+([^:]+):\s*(.+)$/,
  MULTIPLE_ASSIGNMENT: /^([a-zA-Z_]\w*(?:\s*,\s*[a-zA-Z_]\w*)*)\s*=\s*(.+)$/,
  DICTIONARY_LITERAL: /^([a-zA-Z_]\w*)\s*=\s*\{(.*)\}$/,
  DICTIONARY_ACCESS: /([a-zA-Z_]\w*)\[(["'][^"']*["']|\w+)\]/,
  DICTIONARY_ASSIGNMENT: /^([a-zA-Z_]\w*)\[(["'][^"']*["']|\w+)\]\s*=\s*(.+)$/,
  BREAK: /^break\s*$/,
  CONTINUE: /^continue\s*$/,
  TRY: /^try\s*:/,
  EXCEPT: /^except(?:\s+([\w.]+)(?:\s+as\s+\w+)?)?\s*:/, // Captures exception type, and optionally 'as alias'
  EXCEPT_AS: /^except\s+([\w.]+)\s+as\s+(\w+)\s*:/, // Specifically for 'except Type as alias'
  FINALLY: /^finally\s*:/,
  // Object-oriented patterns
  OBJECT_INSTANTIATION: /^([a-zA-Z_]\w*)\s*=\s*(\w+)\(([^)]*)\)$/,
  METHOD_CALL: /^\s*([a-zA-Z_]\w*)\.([a-zA-Z_]\w*)\(([^)]*)\)\s*$/,
  METHOD_ASSIGNMENT: /^([a-zA-Z_]\w*)\s*=\s*([a-zA-Z_]\w*)\.([a-zA-Z_]\w*)\(([^)]*)\)$/,
  SELF_ASSIGNMENT: /^self\.([a-zA-Z_]\w*)\s*=\s*(.+)$/,
  CONSTRUCTOR_DEF: /^def\s+__init__\s*\(([^)]*)\)\s*:/
} as const;